# Seotda Unix Project

이 저장소는 전통적인 한국 고스톱 게임인 "섯다"를 클라이언트-서버 구조로 구현한 예제입니다. 서버(`server`)와 클라이언트(`client`) 애플리케이션이 TCP 소켓을 통해 통신하며, 게임 규칙에 따라 배팅과 카드 비교를 수행합니다.

---

## 📂 파일 구조

unix_project/
├── server.c # 서버 메인 로직
├── client.c # 클라이언트 메인 로직
├── game_protocol.c # 공용 프로토콜 구현 (정렬, 에러 처리)
├── game_protocol.h # 메시지 타입, 구조체 정의
├── Makefile # 빌드 스크립트
└── README.md # 프로젝트 설명 (이 파일)

## 🚀 실행

1. **서버 실행**  
   ```bash
   ./server

2. **클라이언트 실행**
```bash
./client

## 🎮 게임 규칙 요약

1. **예산 설정**  
   - 클라이언트가 서버에 예산(정수)을 전송합니다.

2. **게임 진행**  
   - 서버가 양쪽(플레이어·컴퓨터)에게 카드 2장씩 분배하고 초기 배팅(300원) 상태를 보냅니다.  
   - 플레이어는 1단계 `CALL/DIE`를 선택하고, CALL 시 추가 배팅 금액을 입력합니다.  
   - 두 번째 카드가 공개된 뒤 다시 `CALL/DIE`를 선택하여 추가 배팅을 결정합니다.  
   - 최종적으로 서버가 카드 점수를 비교하여 승패를 결정하고, 예산을 정산합니다.

3. **카드 족보**  
   - `38광땡`, `13광땡`, `18광땡`, 일반 땡, 알리, 독사, 구삥, 장삥, 장사, 세륙, 땡잡이, 암행어사, 멍텅구리구사, 49파토, 끗 계산 방식 적용

4. **재시작**  
   - 예산이 남아 있으면 플레이어가 재시작 여부를 선택할 수 있으며, 서버가 이를 받아 계속 진행하거나 종료합니다.

---

## 📡 프로토콜 개요

- **헤더 전송**: 각 메시지 앞에 `int header`(바이트 크기) 전송  
- **`GameState` 구조체**: 예산, 배팅·선택 정보, 남은 예산 등을 포함  
- **`Card` 구조체**: 카드 번호(`num`), 특수 여부(`special`), 이름(`name[15]`)  
- `Ascending()` 함수로 카드 오름차순 정렬  
- `ErrorCheck()` 함수로 시스템 콜 에러 처리

---

## 📜 라이선스

MIT 라이선스를 따릅니다. 자세한 내용은 `LICENSE` 파일을 참조하세요.
